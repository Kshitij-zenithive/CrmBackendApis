package schema

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.66

import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"

	initializers "github.com/Zenithive/it-crm-backend/Initializers"
	"github.com/Zenithive/it-crm-backend/auth"
	"github.com/Zenithive/it-crm-backend/internal/graphql/generated"
	"github.com/Zenithive/it-crm-backend/models"
	"github.com/Zenithive/it-crm-backend/utils"
	"github.com/google/uuid"
	"golang.org/x/crypto/bcrypt"
	"gorm.io/gorm"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*generated.AuthPayload, error) {
	var user models.User
	if err := initializers.DB.Where("email = ?", email).First(&user).Error; err != nil {
		return nil, errors.New("user not found")
	}
	// Validate password
	err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password))
	if err != nil {
		return nil, errors.New("invalid password")
	}

	// Generate JWT token
	token, err := auth.GenerateJWT(&user)
	if err != nil {
		return nil, errors.New("failed to generate token")
	}

	return &generated.AuthPayload{
		Token: token,
		User: &generated.User{
			UserID:   fmt.Sprintf("%d", user.ID),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Role:     user.Role,
			Password: user.Password,
		},
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input generated.CreateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	if input.Name == "" {
		return nil, fmt.Errorf("name is required")
	}
	if input.Email == "" {
		return nil, fmt.Errorf("email is required")
	}
	if input.Password == "" {
		return nil, fmt.Errorf("password is required")
	}
	if input.Role == "" {
		return nil, fmt.Errorf("role is required")
	}
	if input.Role != "ADMIN" && input.Role != "SALES_EXECUTIVE" && input.Role != "MANAGER" {
		return nil, fmt.Errorf("invalid role")
	}

	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(input.Password), bcrypt.DefaultCost)
	if initializers.DB != nil {
		user := models.User{
			ID:       uuid.New(),
			GoogleId: *input.GoogleID,
			Name:     input.Name,
			Email:    input.Email,
			Phone:    *input.Phone,
			Password: string(hashedPassword),
			Role:     string(input.Role),
		}
		if err != nil {
			return nil, fmt.Errorf("failed to hash password: %v", err)
		}
		result := initializers.DB.Create(&user)
		if result.Error != nil {
			return nil, result.Error
		}
		return &generated.User{
			UserID:   user.ID.String(),
			GoogleID: &user.GoogleId,
			Name:     user.Name,
			Email:    user.Email,
			Phone:    user.Phone,
			Password: user.Password,
			Role:     user.Role,
		}, nil
	}
	return nil, fmt.Errorf("database connection is nil")
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, userID string, input generated.UpdateUserInput) (*generated.User, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error fetching role from JWT: %v", err)
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("%s, unauthorized to update user", role)
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Update the user's fields with the input
	if input.Name != nil {
		user.Name = *input.Name
	}
	if input.Email != nil {
		user.Email = *input.Email
	}
	if input.Phone != nil {
		user.Phone = *input.Phone
	}
	if input.Role != nil {
		user.Role = string(*input.Role)
	}
	if user.Role != "ADMIN" && user.Role != "SALES_EXECUTIVE" && user.Role != "MANAGER" {
		return nil, fmt.Errorf("enter a valid role")
	}

	// Save the updated user record in the database
	if err := initializers.DB.Save(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to update user: %v", err)
	}

	// Return the updated user
	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID string) (*generated.User, error) {

	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to delete user")
	}

	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}
	fmt.Println("User found: ", user)

	// Delete the user record from the database
	if err := initializers.DB.Delete(&user).Error; err != nil {
		return nil, fmt.Errorf("failed to delete user: %v", err)
	}
	fmt.Println("User deleted: ", user)

	// Return the deleted user
	return &generated.User{
		UserID:   fmt.Sprintf("%d", user.ID),
		GoogleID: &user.GoogleId,
		Name:     user.Name,
		Email:    user.Email,
		Phone:    user.Phone,
		Password: user.Password,
		Role:     user.Role,
	}, nil
}

// CreateOrganization is the resolver for the createOrganization field.
func (r *mutationResolver) CreateOrganization(ctx context.Context, input generated.CreateOrganizationInput) (*generated.Organization, error) {
	// Create new organization model instance
	newOrganization := models.Organization{
		OrganizationName:    input.OrganizationName,
		OrganizationEmail:   input.OrganizationEmail,
		OrganizationWebsite: *input.OrganizationWebsite,
		City:                input.City,
		Country:             input.Country,
		NoOfEmployees:       input.NoOfEmployees,
		AnnualRevenue:       input.AnnualRevenue,
	}

	// Save to database
	if err := initializers.DB.Create(&newOrganization).Error; err != nil {
		log.Printf("Error creating organization: %v", err)
		return nil, fmt.Errorf("internal error: failed to create organization")
	}

	// Return the created organization
	return &generated.Organization{
		OrganizationID:      fmt.Sprintf("%d", newOrganization.ID),
		OrganizationName:    newOrganization.OrganizationName,
		OrganizationEmail:   newOrganization.OrganizationEmail,
		OrganizationWebsite: &newOrganization.OrganizationWebsite,
		City:                newOrganization.City,
		Country:             newOrganization.Country,
		NoOfEmployees:       newOrganization.NoOfEmployees,
		AnnualRevenue:       newOrganization.AnnualRevenue,
	}, nil
}

// CreateCampaign is the resolver for the createCampaign field.
func (r *mutationResolver) CreateCampaign(ctx context.Context, input generated.CreateCampaignInput) (*generated.Campaign, error) {
	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting user role")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create campaign")
	}
	// Create new campaign
	newCampaign := models.Campaign{
		ID:               uuid.New(),
		CampaignName:     input.CampaignName,
		CampaignCountry:  input.CampaignCountry,
		CampaignRegion:   input.CampaignRegion,
		IndustryTargeted: input.IndustryTargeted,
	}
	if err := initializers.DB.Create(&newCampaign).Error; err != nil {
		log.Printf("Error creating campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to create campaign")
	}
	return &generated.Campaign{
		CampaignID:       newCampaign.ID.String(),
		CampaignName:     newCampaign.CampaignName,
		CampaignCountry:  newCampaign.CampaignCountry,
		CampaignRegion:   newCampaign.CampaignRegion,
		IndustryTargeted: newCampaign.IndustryTargeted,
	}, nil
}

// AddUserToCampaign is the resolver for the addUserToCampaign field.
func (r *mutationResolver) AddUserToCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: AddUserToCampaign - addUserToCampaign"))

	role, err := auth.GetUserRoleFromJWT(ctx)
	if err != nil {
		return nil, fmt.Errorf("error getting user role")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to add user to campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}
	// Add user to campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Append(&user); err != nil {
		log.Printf("Error adding user to campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to add user to campaign")
	}
	return &generated.Campaign{
		CampaignID:       campaign.ID.String(),
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: user.ID.String(),
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// RemoveUserFromCampaign is the resolver for the removeUserFromCampaign field.
func (r *mutationResolver) RemoveUserFromCampaign(ctx context.Context, userID string, campaignID string) (*generated.Campaign, error) {
	// panic(fmt.Errorf("not implemented: RemoveUserFromCampaign - removeUserFromCampaign"))
	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to remove user from campaign")
	}

	// Check if user is part of the campaign
	var exists bool
	err = initializers.DB.Raw(
		"SELECT EXISTS(SELECT 1 FROM campaign_users WHERE user_id = ? AND campaign_id = ?)", userID, campaignID,
	).Scan(&exists).Error

	if err != nil {
		log.Printf("Error checking user in campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to check user in campaign")
	}

	if !exists {
		return nil, fmt.Errorf("user is not part of this campaign")
	}
	// Find the user by ID
	var user models.User
	if err := initializers.DB.First(&user, "id = ?", userID).Error; err != nil {
		log.Printf("Error finding user: %v", err)
		return nil, fmt.Errorf("internal error: failed to find user")
	}

	// Find the campaign by ID
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", campaignID).Error; err != nil {
		log.Printf("Error finding campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to find campaign")
	}

	// Remove user from campaign
	if err := initializers.DB.Model(&campaign).Association("Users").Delete(&user); err != nil {
		log.Printf("Error removing user from campaign: %v", err)
		return nil, fmt.Errorf("internal error: failed to remove user from campaign")

	}
	return &generated.Campaign{
		CampaignID:       campaignID,
		CampaignName:     campaign.CampaignName,
		CampaignCountry:  campaign.CampaignCountry,
		CampaignRegion:   campaign.CampaignRegion,
		IndustryTargeted: campaign.IndustryTargeted,
		Users: []*generated.User{
			{
				UserID: userID,
				Name:   user.Name,
				Email:  user.Email,
				Phone:  user.Phone,
			},
		},
	}, nil
}

// CreateLead is the resolver for the createLead field.
func (r *mutationResolver) CreateLead(ctx context.Context, input generated.CreateLeadInput) (*generated.Lead, error) {
	// Check if LeadCreatedBy exists
	// var createdByUser models.User

	jwtClaims, _ := auth.GetUserFromJWT(ctx)
	fmt.Println("User from JWT: ", jwtClaims)
	if jwtClaims == nil {
		return nil, errors.New("unauthorized")
	}

	// Check if LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}
	// Check if Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}
	// Check if Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	lead := models.Lead{
		// LeadID:             uuid.New().String(),
		FirstName:  input.FirstName,
		LastName:   input.LastName,
		Email:      input.Email,
		LinkedIn:   input.LinkedIn,
		Country:    input.Country,
		Phone:      input.Phone,
		LeadSource: input.LeadSource,
		// InitialContactDate: input.InitialContactDate,
		// LeadCreatedBy:  userID,
		// LeadAssignedTo: input.LeadAssignedTo,
		// LeadStage:      input.LeadStage.String(),
		// LeadNotes:      input.LeadNotes,
		// LeadPriority:   input.LeadPriority.String(),
		// OrganizationID: input.OrganizationID,
		// CampaignID:     input.CampaignID,
	}

	// Save lead to DB
	if err := initializers.DB.Create(&lead).Error; err != nil {
		return nil, err
	}

	return &generated.Lead{
		// LeadID:             lead.ID,
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		Email:      lead.Email,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		// InitialContactDate: lead.InitialContactDate,
		LeadCreatedBy: &generated.User{
			UserID: userID,
		},
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", assignedToUser.ID),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:   fmt.Sprintf("%d", organization.ID),
			OrganizationName: organization.OrganizationName,
		},

		Campaign: &generated.Campaign{
			CampaignID:   fmt.Sprintf("%d", campaign.ID),
			CampaignName: campaign.CampaignName,
		},
	}, nil
}

// UpdateLead is the resolver for the updateLead field.
func (r *mutationResolver) UpdateLead(ctx context.Context, leadID string, input generated.UpdateLeadInput) (*generated.Lead, error) {
	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}

	// Check if LeadStage is updated to "WON" from a different value
	isWon := input.LeadStage.String() == "CLOSED_WON" && lead.LeadStage != "CLOSED_WON"

	// Update Lead Details
	if err := initializers.DB.Model(&lead).Updates(models.Lead{
		FirstName:  *input.FirstName,
		LastName:   *input.LastName,
		Email:      input.Email,
		LinkedIn:   *input.LinkedIn,
		Country:    *input.Country,
		Phone:      *input.Phone,
		LeadSource: input.LeadSource,
		// InitialContactDate: input.InitialContactDate,
		// LeadAssignedTo: input.LeadAssignedTo,
		// LeadStage:      input.LeadStage.String(),
		// LeadNotes:      input.LeadNotes,
		// LeadPriority:   input.LeadPriority.String(),
		// OrganizationID: input.OrganizationID,
		// CampaignID:     input.CampaignID,
	}).Error; err != nil {
		return nil, err
	}

	// If LeadStage is updated to "WON" and no existing deal, create a new deal
	if isWon {
		existingDeal := models.Deals{}
		if err := initializers.DB.Where("lead_id = ?", leadID).First(&existingDeal).Error; err != nil {
			if errors.Is(err, gorm.ErrRecordNotFound) {
				// Create a new Deal only if it does not exist
				newDeal := models.Deals{
					// LeadID:        leadID,
					DealName:      fmt.Sprintf("Deal for %s %s", lead.FirstName, lead.LastName),
					DealAmount:    "0", // Default, can be updated later
					DealStartDate: time.Now(),
					DealEndDate:   time.Now().AddDate(0, 6, 0), // Example: 6 months duration
					DealStatus:    "Active",
				}
				if err := initializers.DB.Create(&newDeal).Error; err != nil {
					log.Printf("Error creating deal for lead %s: %v", leadID, err)
					return nil, fmt.Errorf("internal error: failed to create deal")
				}
			}
		}
	}

	return &generated.Lead{
		LeadID:     leadID,
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		Email:      lead.Email,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		// InitialContactDate: lead.InitialContactDate,
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", lead.Assignee.ID),
			Name:   lead.Assignee.Name,
			Email:  lead.Assignee.Email,
			Phone:  lead.Assignee.Phone,
		},
		LeadStage:    lead.LeadStage,
		LeadNotes:    lead.LeadNotes,
		LeadPriority: lead.LeadPriority,
		Organization: &generated.Organization{
			// OrganizationID:   lead.OrganizationID,
			OrganizationName: lead.Organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			// CampaignID: lead.CampaignID,
		},
	}, nil
}

// DeleteLead is the resolver for the deleteLead field.
func (r *mutationResolver) DeleteLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: DeleteLead - deleteLead"))

	lead := models.Lead{}
	if err := initializers.DB.First(&lead, "lead_id = ?", leadID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("lead not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&lead).Error; err != nil {
		return nil, err
	}
	return &generated.Lead{
		// LeadID:    lead.LeadID,
		FirstName: lead.FirstName,
		LastName:  lead.LastName,
		Email:     lead.Email,
		LinkedIn:  lead.LinkedIn,
		Country:   lead.Country,
	}, nil
}

// CreateLeadWithActivity is the resolver for the createLeadWithActivity field.
func (r *mutationResolver) CreateLeadWithActivity(ctx context.Context, input generated.CreateLeadWithActivityInput) (*generated.Lead, error) {
	jwtClaims, _ := auth.GetUserFromJWT(ctx)

	fmt.Println("User from JWT: ", jwtClaims)
	// Validate LeadAssignedTo exists
	var assignedToUser models.User
	if err := initializers.DB.First(&assignedToUser, "id = ?", input.LeadAssignedTo).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("assigned user not found")
		}
		return nil, err
	}

	// Validate Organization exists
	var organization models.Organization
	if err := initializers.DB.First(&organization, "id = ?", input.OrganizationID).Error; err != nil {

		fmt.Println("Organization id ", input.OrganizationID)

		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("organization not found")
		}
		return nil, err
	}

	// Validate Campaign exists
	var campaign models.Campaign
	if err := initializers.DB.First(&campaign, "id = ?", input.CampaignID).Error; err != nil {
		fmt.Println("Campaign id ", input.CampaignID)
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("campaign not found")
		}
		return nil, err
	}
	userID, ok := jwtClaims["user_id"].(string)
	fmt.Println("User ID: ", userID)
	if !ok {
		return nil, fmt.Errorf("failed to extract user ID from JWT")
	}
	// Create new lead instance
	newLead := models.Lead{
		// LeadID:             uuid.NewString(),
		FirstName:  input.Firstname,
		LastName:   input.Lastname,
		Email:      input.Email,
		LinkedIn:   input.LinkedIn,
		Country:    input.Country,
		Phone:      input.Phone,
		LeadSource: input.LeadSource,
		// InitialContactDate: input.InitialContactDate,
		// LeadCreatedBy:  userID,
		// LeadAssignedTo: input.LeadAssignedTo,
		// LeadStage:      input.LeadStage.String(),
		// LeadNotes:      input.LeadNotes,
		// LeadPriority:   input.LeadPriority.String(),
		// OrganizationID: input.OrganizationID,
		// CampaignID:     input.CampaignID,
	}

	// Create new activity instance
	newActivity := models.Activity{
		// ActivityID:           uuid.NewString(),
		// LeadID:       fmt.Sprintf("%d", newLead.ID), // Associate the activity with the lead
		ActivityType: input.ActivityType,
		// DateTime:             input.DateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}

	// Use a transaction to ensure both Lead and Activity are created successfully
	err := initializers.DB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Create(&newLead).Error; err != nil {
			log.Printf("Error creating lead: %v", err)
			return fmt.Errorf("internal error: failed to create lead")
		}

		if err := tx.Create(&newActivity).Error; err != nil {
			log.Printf("Error creating activity: %v", err)
			return fmt.Errorf("internal error: failed to create activity")
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	// Return the created lead and its associated activity
	return &generated.Lead{
		// LeadID:             newLead.LeadID,
		FirstName:  newLead.FirstName,
		LastName:   newLead.LastName,
		Email:      newLead.Email,
		LinkedIn:   newLead.LinkedIn,
		Country:    newLead.Country,
		Phone:      newLead.Phone,
		LeadSource: newLead.LeadSource,
		// InitialContactDate: newLead.InitialContactDate,
		LeadCreatedBy: &generated.User{
			UserID: userID,
		},
		LeadAssignedTo: &generated.User{
			UserID: fmt.Sprintf("%d", assignedToUser.ID),
			Name:   assignedToUser.Name,
			Email:  assignedToUser.Email,
		},
		LeadStage:    newLead.LeadStage,
		LeadNotes:    newLead.LeadNotes,
		LeadPriority: newLead.LeadPriority,
		Organization: &generated.Organization{
			OrganizationID:   fmt.Sprintf("%d", organization.ID),
			OrganizationName: organization.OrganizationName,
		},
		Campaign: &generated.Campaign{
			CampaignID:   fmt.Sprintf("%d", campaign.ID),
			CampaignName: campaign.CampaignName,
		},
		Activities: []*generated.Activity{
			{
				// ActivityID:           newActivity.ActivityID,
				// LeadID:       newActivity.LeadID,
				ActivityType: newActivity.ActivityType,
				// DateTime:             newActivity.DateTime,
				CommunicationChannel: newActivity.CommunicationChannel,
				ContentNotes:         newActivity.ContentNotes,
				ParticipantDetails:   newActivity.ParticipantDetails,
				FollowUpActions:      newActivity.FollowUpActions,
			},
		},
	}, nil
}

// CreateDeal is the resolver for the createDeal field.
func (r *mutationResolver) CreateDeal(ctx context.Context, input generated.CreateDealInput) (*generated.Deal, error) {
	// panic(fmt.Errorf("not implemented: CreateDeal - createDeal"))

	// Create new deal
	newDeal := models.Deals{
		// LeadID:     input.LeadID,
		DealName:   input.DealName,
		DealAmount: input.DealAmount,
		// DealStartDate: input.DealStartDate,
		// DealEndDate:   input.DealEndDate,
		DealStatus: input.DealStatus.String(),
	}
	if err := initializers.DB.Create(&newDeal).Error; err != nil {
		log.Printf("Error creating deal: %v", err)
		return nil, fmt.Errorf("internal error: failed to create deal")
	}
	return &generated.Deal{
		DealID: fmt.Sprintf("%d", newDeal.ID),
		// LeadID:     newDeal.LeadID,
		DealName:   newDeal.DealName,
		DealAmount: newDeal.DealAmount,
		DealStatus: newDeal.DealStatus,
	}, nil
}

// CreateActivity is the resolver for the createActivity field.
func (r *mutationResolver) CreateActivity(ctx context.Context, input generated.CreateActivityInput) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: CreateActivity - createActivity"))
	log.Println("CreateActivity input parameters:", input.LeadID, input.ActivityType, input.DateTime, input.CommunicationChannel, input.ContentNotes, input.ParticipantDetails, input.FollowUpActions)
	parsedUUID, err := uuid.Parse(input.LeadID)
	if err != nil {
		return nil, fmt.Errorf("invalid LeadID: %v", err)
	}

	// Create new activity
	newActivity := models.Activity{
		// ActivityID:           uuid.NewString(),
		LeadID:       parsedUUID,
		ActivityType: input.ActivityType,
		// DateTime:             input.DateTime,
		CommunicationChannel: input.CommunicationChannel,
		ContentNotes:         input.ContentNotes,
		ParticipantDetails:   input.ParticipantDetails,
		FollowUpActions:      input.FollowUpActions,
	}
	if err := initializers.DB.Create(&newActivity).Error; err != nil {
		log.Printf("Error creating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to create activity")
	}

	// Map the activity to the GraphQL response type
	return &generated.Activity{
		// ActivityID: newActivity.ActivityID,
		LeadID: newActivity.LeadID.String(),

		ActivityType: newActivity.ActivityType,
		// DateTime:             newActivity.DateTime,
		CommunicationChannel: newActivity.CommunicationChannel,
		ContentNotes:         newActivity.ContentNotes,
		ParticipantDetails:   newActivity.ParticipantDetails,
		FollowUpActions:      newActivity.FollowUpActions,
	}, nil
}

// UpdateActivity is the resolver for the updateActivity field.
func (r *mutationResolver) UpdateActivity(ctx context.Context, activityID string, input generated.UpdateActivityInput) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: UpdateActivity - updateActivity"))

	// Update activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	activity.ActivityType = *input.ActivityType
	// activity.DateTime = *input.DateTime
	activity.CommunicationChannel = *input.CommunicationChannel
	activity.ContentNotes = *input.ContentNotes
	activity.ParticipantDetails = *input.ParticipantDetails
	activity.FollowUpActions = *input.FollowUpActions
	if err := initializers.DB.Save(&activity).Error; err != nil {
		log.Printf("Error updating activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to update activity")
	}
	// Map the activity to the GraphQL response type
	return &generated.Activity{
		// ActivityID:           activity.ActivityID,
		LeadID:       activity.LeadID.String(),
		ActivityType: activity.ActivityType,
		// DateTime:             activity.DateTime,
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// DeleteActivity is the resolver for the deleteActivity field.
func (r *mutationResolver) DeleteActivity(ctx context.Context, activityID string) (*generated.Activity, error) {
	// panic(fmt.Errorf("not implemented: DeleteActivity - deleteActivity"))
	// Delete activity
	var activity models.Activity
	if err := initializers.DB.First(&activity, "id = ?", activityID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("activity not found")
		}
		return nil, err
	}
	if err := initializers.DB.Delete(&activity).Error; err != nil {
		log.Printf("Error deleting activity: %v", err)
		return nil, fmt.Errorf("internal error: failed to delete activity")
	}
	// Map the activity to the GraphQL response type
	return &generated.Activity{
		// ActivityID:           activity.ActivityID,
		LeadID:       activity.LeadID.String(),
		ActivityType: activity.ActivityType,
		// DateTime:             activity.DateTime,
		CommunicationChannel: activity.CommunicationChannel,
		ContentNotes:         activity.ContentNotes,
		ParticipantDetails:   activity.ParticipantDetails,
		FollowUpActions:      activity.FollowUpActions,
	}, nil
}

// CreateResourceProfile is the resolver for the createResourceProfile field.
func (r *mutationResolver) CreateResourceProfile(ctx context.Context, input generated.CreateResourceProfileInput) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: CreateResourceProfile - createResourceProfile"))
	resourceProfile := models.ResourceProfile{
		Type:            models.ResourceType(input.Type),
		FirstName:       input.FirstName,
		LastName:        input.LastName,
		TotalExperience: input.TotalExperience,
		Status:          models.ResourceStatus(input.Status),
	}

	if input.ContactInformation != "" {
		resourceProfile.ContactInformation = []byte(input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}
	// if input.VendorID != nil && *input.VendorID != "" {
	// 	vendorID, err := uuid.Parse(*input.VendorID)
	// 	if err != nil {
	// 		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	// 	}
	// }
	// resourceProfile.VendorID = *input.VendorID
	// Convert string IDs to uint
	skillIDs := make([]uint, len(input.SkillIDs))
	for i, idStr := range input.SkillIDs {
		id, err := strconv.ParseUint(idStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid skill ID %s: %w", idStr, err)
		}
		skillIDs[i] = uint(id)
	}

	if len(input.SkillIDs) > 0 {
		skills, err := utils.FetchSkills(skillIDs)
		if err != nil {
			return nil, err
		}
		resourceProfile.Skills = skills
	}

	if err := initializers.DB.Create(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to create resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),
		Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// UpdateResourceProfile is the resolver for the updateResourceProfile field.
func (r *mutationResolver) UpdateResourceProfile(ctx context.Context, resourceProfileID string, input generated.UpdateResourceProfileInput) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: UpdateResourceProfile - updateResourceProfile")) //
	// resourceProfileID, err := uuid.Parse(id)
	// if err != nil {
	// 	return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	// }

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", resourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	// Update fields using pointers to distinguish between not provided and zero values
	if input.Type != nil {
		resourceProfile.Type = models.ResourceType(*input.Type)
	}
	if input.FirstName != nil {
		resourceProfile.FirstName = *input.FirstName
	}
	if input.LastName != nil {
		resourceProfile.LastName = *input.LastName
	}
	if input.TotalExperience != nil {
		resourceProfile.TotalExperience = *input.TotalExperience
	}
	if input.ContactInformation != nil {
		resourceProfile.ContactInformation = []byte(*input.ContactInformation)
	}
	if input.GoogleDriveLink != nil {
		resourceProfile.GoogleDriveLink = input.GoogleDriveLink
	}
	if input.Status != nil {
		resourceProfile.Status = models.ResourceStatus(*input.Status)
	}
	// if input.VendorID != nil && *input.VendorID != "" {
	// 	vendorID, err := uuid.Parse(*input.VendorID)
	// 	if err != nil {
	// 		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	// 	}
	// 	resourceProfile.VendorID = &vendorID
	// }
	// Convert string IDs to uint
	skillIDs := make([]uint, len(input.SkillIDs))
	for i, idStr := range input.SkillIDs {
		id, err := strconv.ParseUint(idStr, 10, 64)
		if err != nil {
			return nil, fmt.Errorf("invalid skill ID %s: %w", idStr, err)
		}
		skillIDs[i] = uint(id)
	}

	if len(skillIDs) > 0 {
		skills, err := utils.FetchSkills(skillIDs)
		if err != nil {
			return nil, err
		}
		if err := initializers.DB.Model(&resourceProfile).Association("Skills").Replace(skills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to update resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),

		Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// DeleteResourceProfile is the resolver for the deleteResourceProfile field.
func (r *mutationResolver) DeleteResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: DeleteResourceProfile - deleteResourceProfile"))
	parsedResourceProfileID, err := uuid.Parse(resourceProfileID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", parsedResourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	if err := initializers.DB.Delete(&resourceProfile).Error; err != nil {
		return nil, fmt.Errorf("failed to delete resource profile: %w", err)
	}

	return &generated.ResourceProfile{
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),
		Skills: utils.ConvertSkills(resourceProfile.Skills),
	}, nil
}

// CreateVendor is the resolver for the createVendor field.
func (r *mutationResolver) CreateVendor(ctx context.Context, input generated.CreateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: CreateVendor - createVendor"))
	vendor := models.Vendor{
		CompanyName:  input.CompanyName,
		Status:       models.VendorStatus(input.Status),       // Enum conversion
		PaymentTerms: models.PaymentTerms(input.PaymentTerms), // Enum conversion
		Address:      input.Address,
	}

	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many)
	if len(input.SkillIDs) > 0 {
		var skills []models.Skill
		for _, skillIDStr := range input.SkillIDs {
			// skillID, err := uuid.Parse(skillIDStr)
			// if err != nil {
			// 	return nil, fmt.Errorf("invalid skill ID: %w", err)
			// }
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillIDStr).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			skills = append(skills, skill)
		}
		vendor.Skills = skills
	}

	if err := initializers.DB.Create(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to create vendor: %w", err)
	}
	return &generated.Vendor{
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// UpdateVendor is the resolver for the updateVendor field.
func (r *mutationResolver) UpdateVendor(ctx context.Context, vendorID string, input generated.UpdateVendorInput) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: UpdateVendor - updateVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", parsedVendorID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	if input.CompanyName != nil {
		vendor.CompanyName = *input.CompanyName
	}
	if input.Status != nil {
		vendor.Status = models.VendorStatus(*input.Status)
	}
	if input.PaymentTerms != nil {
		vendor.PaymentTerms = models.PaymentTerms(*input.PaymentTerms)
	}
	if input.Address != nil {
		vendor.Address = *input.Address
	}
	if input.GstOrVatDetails != nil {
		vendor.GstOrVatDetails = input.GstOrVatDetails
	}
	if input.Notes != nil {
		vendor.Notes = input.Notes
	}

	// Handle Skills (many-to-many) - Replace existing skills.
	if input.SkillIDs != nil {
		var newSkills []models.Skill
		for _, skillIDStr := range input.SkillIDs {
			skillID, err := uuid.Parse(skillIDStr)
			if err != nil {
				return nil, fmt.Errorf("invalid skill ID: %w", err)
			}
			var skill models.Skill
			if err := initializers.DB.First(&skill, "id = ?", skillID).Error; err != nil {
				if errors.Is(err, gorm.ErrRecordNotFound) {
					return nil, fmt.Errorf("skill with ID %s not found", skillIDStr)
				}
				return nil, fmt.Errorf("error retrieving skill: %w", err)
			}
			newSkills = append(newSkills, skill)
		}
		if err := initializers.DB.Model(&vendor).Association("Skills").Replace(newSkills); err != nil {
			return nil, fmt.Errorf("failed to update skills: %w", err)
		}
	}

	if err := initializers.DB.Save(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to update vendor: %w", err)
	}
	return &generated.Vendor{
		// ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// DeleteVendor is the resolver for the deleteVendor field.
func (r *mutationResolver) DeleteVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: DeleteVendor - deleteVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", vendor.ID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	// GORM's soft delete.  Use Unscoped() to permanently delete (if needed).
	if err := initializers.DB.Delete(&vendor).Error; err != nil {
		return nil, fmt.Errorf("failed to delete vendor: %w", err)
	}

	return &generated.Vendor{
		// ID:              vendor.ID.String(),
		CompanyName:     vendor.CompanyName,
		Status:          generated.VendorStatus(vendor.Status),
		PaymentTerms:    generated.PaymentTerms(vendor.PaymentTerms),
		Address:         vendor.Address,
		GstOrVatDetails: vendor.GstOrVatDetails,
		Notes:           vendor.Notes,
		Skills:          utils.ConvertSkills(vendor.Skills),
	}, nil
}

// CreateCaseStudy is the resolver for the createCaseStudy field.
func (r *mutationResolver) CreateCaseStudy(ctx context.Context, input generated.CreateCaseStudyInput) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: CreateCaseStudy - createCaseStudy"))
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}
	caseStudy := models.CaseStudy{
		// CaseStudyID:     uuid.New().String(), // Generate a unique ID
		ProjectName:     input.ProjectName,
		ClientName:      input.ClientName,
		TechStack:       input.TechStack,
		ProjectDuration: input.ProjectDuration,
		KeyOutcomes:     input.KeyOutcomes,
		IndustryTarget:  input.IndustryTarget,
		Tags:            input.Tags,
		Document:        input.Document,
	}

	if err := initializers.DB.Create(&caseStudy).Error; err != nil {
		return nil, err
	}

	return &generated.CaseStudy{
		CaseStudyID:     fmt.Sprintf("%d", caseStudy.ID),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// UpdateCaseStudy is the resolver for the updateCaseStudy field.
func (r *mutationResolver) UpdateCaseStudy(ctx context.Context, caseStudyID string, input generated.UpdateCaseStudyInput) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: UpdateCaseStudy - updateCaseStudy"))
	var caseStudy models.CaseStudy

	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, err // Case study not found
	}

	// Update fields
	caseStudy.ProjectName = input.ProjectName
	caseStudy.ClientName = input.ClientName
	caseStudy.TechStack = input.TechStack
	caseStudy.ProjectDuration = input.ProjectDuration
	caseStudy.KeyOutcomes = input.KeyOutcomes
	caseStudy.IndustryTarget = input.IndustryTarget
	caseStudy.Tags = input.Tags
	caseStudy.Document = input.Document

	if err := initializers.DB.Save(&caseStudy).Error; err != nil {
		return nil, err
	}

	return &generated.CaseStudy{
		CaseStudyID:     fmt.Sprintf("%d", caseStudy.ID),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// DeleteCaseStudy is the resolver for the deleteCaseStudy field.
func (r *mutationResolver) DeleteCaseStudy(ctx context.Context, caseStudyID string) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: DeleteCaseStudy - deleteCaseStudy"))
	var caseStudy models.CaseStudy
	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, err // Case study not found
	}
	if err := initializers.DB.Delete(&caseStudy).Error; err != nil {
		return nil, err
	}
	return &generated.CaseStudy{
		CaseStudyID:     fmt.Sprintf("%d", caseStudy.ID),
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, filter *generated.UserFilter, pagination *generated.PaginationInput, sort *generated.UserSortInput) (*generated.UserPage, error) {
	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to get user")
	}

	var users []models.User
	query := initializers.DB.Model(&models.User{}).
		Joins("LEFT JOIN campaign_users ON users.id = campaign_users.user_id").
		Joins("LEFT JOIN campaigns ON campaign_users.campaign_id = campaigns.id").
		Preload("Campaigns")

	// --- Apply Filters ---
	if filter != nil {
		if filter.Name != nil && *filter.Name != "" {
			query = query.Where("users.name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Email != nil && *filter.Email != "" {
			query = query.Where("users.email ILIKE ?", "%"+*filter.Email+"%")
		}
		if filter.Role != nil && *filter.Role != "" {
			query = query.Where("users.role = ?", *filter.Role)
		}
		if filter.Search != nil && *filter.Search != "" {
			query = query.Where("users.name ILIKE ? OR users.email ILIKE ?", "%"+*filter.Search+"%", "%"+*filter.Search+"%")
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.UserSortFieldName:
			query = query.Order("users.name " + order)
		case generated.UserSortFieldEmail:
			query = query.Order("users.email " + order)
		case generated.UserSortFieldRole:
			query = query.Order("users.role " + order)
		case generated.UserSortFieldCreatedAt:
			query = query.Order("users.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := int((pagination.Page - 1) * pagination.PageSize)
		query = query.Offset(offset).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&users).Error; err != nil {
		log.Printf("Error fetching users: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch users")
	}

	// Map to GraphQL response type
	var result []*generated.User
	for _, c := range users {
		var campaigns []*generated.Campaign
		for _, u := range c.Campaigns {
			campaigns = append(campaigns, &generated.Campaign{
				CampaignID:       u.ID.String(),
				CampaignName:     u.CampaignName,
				CampaignCountry:  u.CampaignCountry,
				CampaignRegion:   u.CampaignRegion,
				IndustryTargeted: u.IndustryTargeted,
			})
		}
		result = append(result, &generated.User{
			UserID:    c.ID.String(),
			GoogleID:  &c.GoogleId,
			Name:      c.Name,
			Email:     c.Email,
			Phone:     c.Phone,
			Role:      c.Role,
			Password:  c.Password,
			Campaigns: campaigns,
		})
	}

	return &generated.UserPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, userID string) (*generated.User, error) {

	if initializers.DB == nil {
		return nil, fmt.Errorf("database connection is nil")
	}

	role, err := auth.GetUserRoleFromJWT(ctx)
	fmt.Println("Role: ", role)
	if err != nil {
		return nil, fmt.Errorf("unauthorized")
	}
	if role != "ADMIN" && role != "MANAGER" {
		return nil, fmt.Errorf("unauthorized to create user")
	}

	// Find the user by ID and preload campaigns
	var user models.User
	if err := initializers.DB.Preload("Campaigns").First(&user, "id = ?", userID).Error; err != nil {
		return nil, fmt.Errorf("user not found: %v", err)
	}

	// Map campaigns
	var campaigns []*generated.Campaign
	for _, c := range user.Campaigns {
		campaigns = append(campaigns, &generated.Campaign{
			CampaignID:       c.ID.String(),
			CampaignName:     c.CampaignName,
			CampaignCountry:  c.CampaignCountry,
			CampaignRegion:   c.CampaignRegion,
			IndustryTargeted: c.IndustryTargeted,
		})
	}

	// Map the user to the GraphQL response type
	return &generated.User{
		UserID:    user.ID.String(),
		GoogleID:  &user.GoogleId,
		Name:      user.Name,
		Email:     user.Email,
		Phone:     user.Phone,
		Role:      user.Role,
		Password:  user.Password,
		Campaigns: campaigns, // Include campaigns in response
	}, nil
}

// GetCampaigns is the resolver for the getCampaigns field.
func (r *queryResolver) GetCampaigns(ctx context.Context, filter *generated.CampaignFilter, pagination *generated.PaginationInput, sort *generated.CampaignSortInput) (*generated.CampaignPage, error) {
	var campaigns []models.Campaign

	// Preload Users so that each Campaign comes with its associated users.
	query := initializers.DB.Model(&models.Campaign{}).Preload("Users")

	// --- Apply Filters ---
	if filter != nil {
		if filter.CampaignName != nil && *filter.CampaignName != "" {
			query = query.Where("campaigns.campaign_name ILIKE ?", "%"+*filter.CampaignName+"%")
		}
		if filter.CampaignCountry != nil && *filter.CampaignCountry != "" {
			query = query.Where("campaigns.campaign_country = ?", *filter.CampaignCountry)
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.CampaignSortFieldCampaignName:
			query = query.Order("campaigns.campaign_name " + order)
		case generated.CampaignSortFieldCreatedAt:
			query = query.Order("campaigns.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&campaigns).Error; err != nil {
		log.Printf("Error fetching campaigns: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch campaigns")
	}

	// Map the campaigns to your GraphQL type, including the associated users.
	var result []*generated.Campaign
	for _, c := range campaigns {
		// Map associated users for each campaign.
		var users []*generated.User
		for _, u := range c.Users {
			users = append(users, &generated.User{
				UserID:   u.ID.String(),
				GoogleID: &u.GoogleId,
				Name:     u.Name,
				Email:    u.Email,
				Role:     u.Role,
				Phone:    u.Phone,
				// You can map additional fields as needed.
			})
		}

		result = append(result, &generated.Campaign{
			CampaignID:      c.ID.String(),
			CampaignName:    c.CampaignName,
			CampaignCountry: c.CampaignCountry,
			// Map additional campaign fields if needed.
			Users: users, // This field should be defined in your GraphQL Campaign type.
		})
	}

	return &generated.CampaignPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetCampaign is the resolver for the getCampaign field.
func (r *queryResolver) GetCampaign(ctx context.Context, campaignID string) (*generated.Campaign, error) {
	// Retrieve the campaign with the given ID, preloading the associated Users.
	var campaign models.Campaign
	if err := initializers.DB.
		Preload("Users").
		Where("id = ?", campaignID).
		First(&campaign).Error; err != nil {
		log.Printf("Error fetching campaign %s: %v", campaignID, err)
		return nil, fmt.Errorf("internal error: failed to fetch campaign")
	}

	// Map the associated users to the GraphQL type.
	var users []*generated.User
	for _, u := range campaign.Users {
		users = append(users, &generated.User{
			UserID:   u.ID.String(),
			GoogleID: &u.GoogleId,
			Name:     u.Name,
			Email:    u.Email,
			Role:     u.Role,
			Phone:    u.Phone,
			// Map any additional user fields as needed.
		})
	}

	// Map the campaign to the GraphQL type, including the nested users.
	result := &generated.Campaign{
		CampaignID:      campaign.ID.String(),
		CampaignName:    campaign.CampaignName,
		CampaignCountry: campaign.CampaignCountry,
		// Include any additional campaign fields as needed.
		Users: users,
	}

	return result, nil
}

// GetLeads is the resolver for the getLeads field.
func (r *queryResolver) GetLeads(ctx context.Context, filter *generated.LeadFilter, pagination *generated.PaginationInput, sort *generated.LeadSortInput) (*generated.LeadPage, error) {
	// panic(fmt.Errorf("not implemented: GetLeads - getLeads"))
	log.Println("GetAllLeads called")

	var leads []models.Lead
	query := initializers.DB.Model(&models.Lead{})

	// --- Apply Filters ---
	if filter != nil {
		if filter.Name != nil && *filter.Name != "" {
			query = query.Where("leads.first_name ILIKE ?", "%"+*filter.Name+"%")
		}
		if filter.Email != nil && *filter.Email != "" {
			query = query.Where("leads.email ILIKE ?", "%"+*filter.Email+"%")
		}
	}

	// --- Apply Sorting ---
	if sort != nil {
		order := "ASC"
		if sort.Order == generated.SortOrderDesc {
			order = "DESC"
		}
		switch sort.Field {
		case generated.LeadSortFieldFirstName:
			query = query.Order("leads.first_name " + order)
		case generated.LeadSortFieldLastName:
			query = query.Order("leads.last_name " + order)
		case generated.LeadSortFieldEmail:
			query = query.Order("leads.email " + order)
		case generated.LeadSortFieldCreatedAt:
			query = query.Order("leads.created_at " + order)
		}
	}

	// --- Apply Pagination ---
	var totalCount int64
	query.Count(&totalCount) // Get total count before applying pagination

	if pagination != nil {
		offset := (pagination.Page - 1) * pagination.PageSize
		query = query.Offset(int(offset)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := query.Find(&leads).Error; err != nil {
		log.Printf("Error fetching leads: %v", err)
		return nil, fmt.Errorf("internal error: failed to fetch leads")
	}
	log.Printf("Leads found: %v", leads) // Add this

	// Map to GraphQL response type
	var result []*generated.Lead
	for _, lead := range leads {
		var activities []*generated.Activity
		for _, activity := range lead.Activities {
			activities = append(activities, &generated.Activity{
				// ActivityID:           activity.ActivityID,
				// LeadID:       activity.LeadID,
				ActivityType: activity.ActivityType,
				// DateTime:             activity.DateTime,
				CommunicationChannel: activity.CommunicationChannel,
				ContentNotes:         activity.ContentNotes,
				ParticipantDetails:   activity.ParticipantDetails,
				FollowUpActions:      activity.FollowUpActions,
			})
		}

		// Map Organization
		var organization *generated.Organization
		// if lead.OrganizationID != "" {
		// 	organization = &generated.Organization{
		// 		OrganizationID:   fmt.Sprintf("%d", lead.Organization.ID),
		// 		OrganizationName: lead.Organization.OrganizationName,
		// 	}
		// }

		// Map Campaign
		var campaign *generated.Campaign
		// if lead.CampaignID != "" {
		// 	campaign = &generated.Campaign{
		// 		CampaignID:       fmt.Sprintf("%d", lead.Campaign.ID),
		// 		CampaignName:     lead.Campaign.CampaignName,
		// 		CampaignCountry:  lead.Campaign.CampaignCountry,
		// 		CampaignRegion:   lead.Campaign.CampaignRegion,
		// 		IndustryTargeted: lead.Campaign.IndustryTargeted,
		// 	}
		// }

		// fmt.Println("creator:", lead.Creator.ID)
		// fmt.Println("assignee:", lead.Assignee.ID)

		result = append(result, &generated.Lead{
			// LeadID:     lead.LeadID,
			FirstName:  lead.FirstName,
			LastName:   lead.LastName,
			LinkedIn:   lead.LinkedIn,
			Email:      lead.Email,
			Country:    lead.Country,
			Phone:      lead.Phone,
			LeadSource: lead.LeadSource,
			// LeadCreatedBy: &generated.User{
			// 	UserID: lead.LeadCreatedBy,
			// 	Name:   lead.Creator.Name,
			// },
			// LeadAssignedTo: &generated.User{
			// 	UserID: lead.LeadAssignedTo,
			// 	Name:   lead.Assignee.Name,
			// },
			LeadStage:    lead.LeadStage,
			LeadPriority: lead.LeadPriority,
			LeadNotes:    lead.LeadNotes,
			// InitialContactDate: lead.InitialContactDate,
			Activities:   activities,
			Organization: organization,
			Campaign:     campaign,
		})

	}

	return &generated.LeadPage{
		Items:      result,
		TotalCount: int32(totalCount),
	}, nil
}

// GetLead is the resolver for the getLead field.
func (r *queryResolver) GetLead(ctx context.Context, leadID string) (*generated.Lead, error) {
	// panic(fmt.Errorf("not implemented: GetLead - getLead"))
	role, _ := auth.GetUserRoleFromJWT(ctx)
	if role == "" {
		fmt.Println("Role is empty")
		return nil, fmt.Errorf("missing token")
	}

	// Find the lead by ID
	var lead models.Lead
	if err := initializers.DB.Preload("Activities").Preload("Organization").Preload("Campaign").First(&lead, "lead_id = ?", leadID).Error; err != nil {
		return nil, err
	}

	// Map the lead to the GraphQL response type
	var activities []*generated.Activity
	for _, activity := range lead.Activities {
		activities = append(activities, &generated.Activity{
			// ActivityID:           activity.ActivityID,

			// LeadID:       activity.LeadID,
			ActivityType: activity.ActivityType,
			// DateTime:             activity.DateTime,
			CommunicationChannel: activity.CommunicationChannel,
			ContentNotes:         activity.ContentNotes,
			ParticipantDetails:   activity.ParticipantDetails,
		})
	}

	// Map Organization
	var organization *generated.Organization
	// if lead.OrganizationID != "" {
	// 	organization = &generated.Organization{
	// 		OrganizationID:   fmt.Sprintf("%d", lead.Organization.ID),
	// 		OrganizationName: lead.Organization.OrganizationName,
	// 	}
	// }

	// // Map Campaign
	// var campaign *generated.Campaign
	// if lead.CampaignID != "" {
	// 	campaign = &generated.Campaign{
	// 		CampaignID:       fmt.Sprintf("%d", lead.Campaign.ID),
	// 		CampaignName:     lead.Campaign.CampaignName,
	// 		CampaignCountry:  lead.Campaign.CampaignCountry,
	// 		CampaignRegion:   lead.Campaign.CampaignRegion,
	// 		IndustryTargeted: lead.Campaign.IndustryTargeted,
	// 	}
	// }

	// Map the lead to the GraphQL response type
	return &generated.Lead{
		// LeadID:     lead.LeadID,
		FirstName:  lead.FirstName,
		LastName:   lead.LastName,
		LinkedIn:   lead.LinkedIn,
		Country:    lead.Country,
		Phone:      lead.Phone,
		LeadSource: lead.LeadSource,
		// LeadCreatedBy:      lead.LeadCreatedBy,
		// LeadAssignedTo:     lead.LeadAssignedTo,
		LeadStage:    lead.LeadStage,
		LeadPriority: lead.LeadPriority,
		LeadNotes:    lead.LeadNotes,
		// InitialContactDate: lead.InitialContactDate,
		Activities:   activities,
		Organization: organization,
		// Campaign:     campaign,
	}, nil
}

// GetOrganizations is the resolver for the getOrganizations field.
func (r *queryResolver) GetOrganizations(ctx context.Context) ([]*generated.Organization, error) {
	// Check database connection
	if _, err := initializers.DB.DB(); err != nil {
		log.Fatalf("Database connection error: %v", err)
		return nil, err
	}

	var organizations []models.Organization

	// Fetch all organizations
	if err := initializers.DB.Find(&organizations).Error; err != nil {
		log.Printf("Error fetching organizations: %v", err)
		return nil, err
	}

	// Convert to GraphQL response type
	var result []*generated.Organization
	for _, org := range organizations {
		result = append(result, &generated.Organization{
			OrganizationID:   fmt.Sprintf("%d", org.ID),
			OrganizationName: org.OrganizationName,
			Country:          org.Country,
		})
	}

	return result, nil
}

// GetOrganization is the resolver for the getOrganization field.
func (r *queryResolver) GetOrganization(ctx context.Context, organizationID string) (*generated.Organization, error) {
	panic(fmt.Errorf("not implemented: GetOrganization - getOrganization"))
}

// GetResourceProfiles is the resolver for the getResourceProfiles field.
func (r *queryResolver) GetResourceProfiles(ctx context.Context, filter *generated.ResourceProfileFilter, pagination *generated.PaginationInput, sort *generated.ResourceProfileSortInput) (*generated.ResourceProfilePage, error) {
	// panic(fmt.Errorf("not implemented: GetResourceProfiles - getResourceProfiles"))
	var resourceProfiles []models.ResourceProfile
	var totalCount int64

	db := initializers.DB.Model(&models.ResourceProfile{})

	// Apply filtering
	if filter != nil {
		if filter.Type != nil {
			db = db.Where("type = ?", *filter.Type)
		}
		if filter.FirstName != nil {
			db = db.Where("first_name ILIKE ?", "%"+*filter.FirstName+"%")
		}
		if filter.LastName != nil {
			db = db.Where("last_name ILIKE ?", "%"+*filter.LastName+"%")
		}
		if filter.TotalExperienceMin != nil {
			db = db.Where("total_experience >= ?", *filter.TotalExperienceMin)
		}
		if filter.TotalExperienceMax != nil {
			db = db.Where("total_experience <= ?", *filter.TotalExperienceMax)
		}
		if filter.Status != nil {
			db = db.Where("status = ?", *filter.Status)
		}
		if filter.VendorID != nil {
			db = db.Where("vendor_id = ?", *filter.VendorID)
		}
		if filter.Search != nil {
			searchPattern := "%" + *filter.Search + "%"
			db = db.Where(
				"first_name ILIKE ? OR last_name ILIKE ? OR EXISTS (SELECT 1 FROM vendors WHERE vendors.id = resource_profiles.vendor_id AND vendors.company_name ILIKE ?)",
				searchPattern, searchPattern, searchPattern,
			)
		}
		if len(filter.SkillIDs) > 0 {
			// Join with the resource_skills table and filter by skill IDs
			db = db.Joins("JOIN resource_skills ON resource_skills.resource_profile_id = resource_profiles.id").
				Where("resource_skills.skill_id IN ?", filter.SkillIDs)
		}
	}
	// Apply sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.ResourceProfileSortFieldCreatedAt:
			db = db.Order("created_at " + sortOrder)
		case generated.ResourceProfileSortFieldUpdatedAt:
			db = db.Order("updated_at " + sortOrder)
		case generated.ResourceProfileSortFieldFirstName:
			db = db.Order("first_name " + sortOrder)
		case generated.ResourceProfileSortFieldLastName:
			db = db.Order("last_name " + sortOrder)
		case generated.ResourceProfileSortFieldTotalExperience:
			db = db.Order("total_experience " + sortOrder)
		case generated.ResourceProfileSortFieldStatus:
			db = db.Order("status " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		db = db.Order("created_at desc")
	}

	// Count total records before applying limit/offset for pagination
	db.Count(&totalCount)
	// Apply pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := db.Preload("Skills").Preload("Vendor").Find(&resourceProfiles).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve resource profiles: %w", err)
	}

	// Convert to generated type
	generatedProfiles := make([]*generated.ResourceProfile, len(resourceProfiles))
	for i, profile := range resourceProfiles {

		//convert pastProjects
		var generatedPastProjects []*generated.PastProject

		generatedProfiles[i] = &generated.ResourceProfile{
			// ID:                 profile.ID.String(),
			Type:               generated.ResourceType(profile.Type),
			FirstName:          profile.FirstName,
			LastName:           profile.LastName,
			TotalExperience:    profile.TotalExperience,
			Status:             generated.ResourceStatus(profile.Status),
			ContactInformation: string(profile.ContactInformation),
			GoogleDriveLink:    profile.GoogleDriveLink,
			// VendorID: func() string {
			// 	if profile.VendorID == "" {
			// 		return ""
			// 	}
			// 	return profile.VendorID
			// }(),
			Vendor: func() *generated.Vendor { // Handle Vendor conversion
				if profile.Vendor == nil {
					return nil
				}
				return &generated.Vendor{
					// ID:          profile.Vendor.ID.String(),
					CompanyName: profile.Vendor.CompanyName,
					Status:      generated.VendorStatus(profile.Vendor.Status),
					// ... other Vendor fields ...
					//convert skills
					Skills: []*generated.Skill{},
					//convert contact list
					ContactList: []*generated.Contact{},
					//convert performance ratings
					PerformanceRatings: []*generated.PerformanceRating{},
					//convert resources
					Resources: []*generated.ResourceProfile{},
				}
			}(),
			Skills:       utils.ConvertSkills(profile.Skills), // Use the helper function
			PastProjects: generatedPastProjects,
		}
	}

	return &generated.ResourceProfilePage{
		Items:      generatedProfiles,
		TotalCount: int32(totalCount),
	}, nil
}

// GetResourceProfile is the resolver for the getResourceProfile field.
func (r *queryResolver) GetResourceProfile(ctx context.Context, resourceProfileID string) (*generated.ResourceProfile, error) {
	// panic(fmt.Errorf("not implemented: GetResourceProfile - getResourceProfile"))
	parsedResourceProfileID, err := uuid.Parse(resourceProfileID)
	if err != nil {
		return nil, fmt.Errorf("invalid resource profile ID: %w", err)
	}

	var resourceProfile models.ResourceProfile
	if err := initializers.DB.Preload("Skills").First(&resourceProfile, "id = ?", parsedResourceProfileID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("resource profile with ID %s not found", resourceProfileID)
		}
		return nil, fmt.Errorf("error retrieving resource profile: %w", err)
	}

	//convert pastProjects
	var generatedPastProjects []*generated.PastProject

	return &generated.ResourceProfile{
		// ID:                 resourceProfile.ID.String(),
		Type:               generated.ResourceType(resourceProfile.Type),
		FirstName:          resourceProfile.FirstName,
		LastName:           resourceProfile.LastName,
		TotalExperience:    resourceProfile.TotalExperience,
		Status:             generated.ResourceStatus(resourceProfile.Status),
		ContactInformation: string(resourceProfile.ContactInformation),
		GoogleDriveLink:    resourceProfile.GoogleDriveLink,
		// VendorID: func() string {
		// 	if resourceProfile.VendorID == "" {
		// 		return ""
		// 	}
		// 	return resourceProfile.VendorID
		// }(),
		Vendor: func() *generated.Vendor { // Handle the nested Vendor conversion
			if resourceProfile.Vendor == nil {
				return nil
			}
			return &generated.Vendor{
				// ID:          resourceProfile.Vendor.ID.String(),
				CompanyName: resourceProfile.Vendor.CompanyName,
				Status:      generated.VendorStatus(resourceProfile.Vendor.Status),
				// ... other Vendor fields ...
				//convert skills
				Skills: []*generated.Skill{},
				//convert contact list
				ContactList: []*generated.Contact{},
				//convert performance ratings
				PerformanceRatings: []*generated.PerformanceRating{},
				//convert resources
				Resources: []*generated.ResourceProfile{},
			}
		}(),
		Skills:       utils.ConvertSkills(resourceProfile.Skills), // Convert skills
		PastProjects: generatedPastProjects,
	}, nil
}

// GetVendors is the resolver for the getVendors field.
func (r *queryResolver) GetVendors(ctx context.Context, filter *generated.VendorFilter, pagination *generated.PaginationInput, sort *generated.VendorSortInput) (*generated.VendorPage, error) {
	// panic(fmt.Errorf("not implemented: GetVendors - getVendors"))
	var vendors []models.Vendor
	var totalCount int64

	db := initializers.DB.Model(&models.Vendor{})

	// Apply filtering
	if filter != nil {
		if filter.CompanyName != nil {
			db = db.Where("company_name ILIKE ?", "%"+*filter.CompanyName+"%")
		}
		if filter.Status != nil {
			db = db.Where("status = ?", *filter.Status)
		}
		if filter.PaymentTerms != nil {
			db = db.Where("payment_terms = ?", *filter.PaymentTerms)
		}
		if filter.Search != nil {
			searchPattern := "%" + *filter.Search + "%"
			db = db.Where("company_name ILIKE ? OR address ILIKE ?", searchPattern, searchPattern)
		}
		if len(filter.SkillIDs) > 0 {
			db = db.Joins("JOIN vendor_skills ON vendor_skills.vendor_id = vendors.id").
				Where("vendor_skills.skill_id IN ?", filter.SkillIDs)
		}
	}

	// Apply sorting
	if sort != nil {
		var sortOrder string
		if sort.Order == generated.SortOrderAsc {
			sortOrder = "asc"
		} else {
			sortOrder = "desc"
		}

		switch sort.Field {
		case generated.VendorSortFieldCreatedAt:
			db = db.Order("created_at " + sortOrder)
		case generated.VendorSortFieldUpdatedAt:
			db = db.Order("updated_at " + sortOrder)
		case generated.VendorSortFieldCompanyName:
			db = db.Order("company_name " + sortOrder)
		case generated.VendorSortFieldStatus:
			db = db.Order("status " + sortOrder)
		default:
			return nil, fmt.Errorf("invalid sort field: %v", sort.Field)
		}
	} else {
		//default sorting
		db = db.Order("created_at desc")
	}

	// Count total records before applying limit/offset for pagination
	db.Count(&totalCount)

	// Apply pagination
	if pagination != nil {
		db = db.Offset(int((pagination.Page - 1) * pagination.PageSize)).Limit(int(pagination.PageSize))
	}

	// Execute the query
	if err := db.Preload("Skills").Find(&vendors).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve vendors: %w", err)
	}

	// Convert to generated type
	generatedVendors := make([]*generated.Vendor, len(vendors))
	for i, vendor := range vendors {
		//convert skills
		var generatedSkills []*generated.Skill
		//convert contact list
		var generatedContactList []*generated.Contact
		//convert performance ratings
		var generatedPerformanceRatings []*generated.PerformanceRating
		//convert resources
		var generatedResources []*generated.ResourceProfile

		generatedVendors[i] = &generated.Vendor{
			// ID:                 vendor.ID.String(),
			CompanyName:        vendor.CompanyName,
			Status:             generated.VendorStatus(vendor.Status),
			PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
			Address:            vendor.Address,
			GstOrVatDetails:    vendor.GstOrVatDetails,
			Notes:              vendor.Notes,
			Skills:             generatedSkills,
			ContactList:        generatedContactList,
			PerformanceRatings: generatedPerformanceRatings,
			Resources:          generatedResources,
		}
	}

	return &generated.VendorPage{
		Items:      generatedVendors,
		TotalCount: int32(totalCount),
	}, nil
}

// GetVendor is the resolver for the getVendor field.
func (r *queryResolver) GetVendor(ctx context.Context, vendorID string) (*generated.Vendor, error) {
	// panic(fmt.Errorf("not implemented: GetVendor - getVendor"))
	parsedVendorID, err := uuid.Parse(vendorID)
	if err != nil {
		return nil, fmt.Errorf("invalid vendor ID: %w", err)
	}

	var vendor models.Vendor
	if err := initializers.DB.Preload("Skills").First(&vendor, "id = ?", parsedVendorID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, fmt.Errorf("vendor with ID %s not found", parsedVendorID)
		}
		return nil, fmt.Errorf("error retrieving vendor: %w", err)
	}

	//convert skills
	var generatedSkills []*generated.Skill
	//convert contact list
	var generatedContactList []*generated.Contact
	//convert performance ratings
	var generatedPerformanceRatings []*generated.PerformanceRating
	//convert resources
	var generatedResources []*generated.ResourceProfile
	return &generated.Vendor{
		// ID:                 vendor.ID.String(),
		CompanyName:        vendor.CompanyName,
		Status:             generated.VendorStatus(vendor.Status),
		PaymentTerms:       generated.PaymentTerms(vendor.PaymentTerms),
		Address:            vendor.Address,
		GstOrVatDetails:    vendor.GstOrVatDetails,
		Notes:              vendor.Notes,
		Skills:             generatedSkills,
		ContactList:        generatedContactList,
		PerformanceRatings: generatedPerformanceRatings,
		Resources:          generatedResources,
	}, nil
}

// GetAllCaseStudy is the resolver for the getAllCaseStudy field.
func (r *queryResolver) GetAllCaseStudy(ctx context.Context) ([]*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: GetAllCaseStudy - getAllCaseStudy"))
	var caseStudies []*models.CaseStudy
	// Fetch all case studies from the database
	if err := initializers.DB.Find(&caseStudies).Error; err != nil {
		return nil, fmt.Errorf("failed to retrieve case studies: %v", err)
	}
	// Convert models to GraphQL generated type
	var gqlCaseStudies []*generated.CaseStudy
	for _, cs := range caseStudies {
		gqlCaseStudies = append(gqlCaseStudies, &generated.CaseStudy{
			CaseStudyID:     fmt.Sprintf("%d", cs.ID),
			ProjectName:     cs.ProjectName,
			ClientName:      cs.ClientName,
			TechStack:       cs.TechStack,
			ProjectDuration: cs.ProjectDuration,
			KeyOutcomes:     cs.KeyOutcomes,
			IndustryTarget:  cs.IndustryTarget,
			Tags:            cs.Tags,
			Document:        cs.Document,
		})
	}
	return gqlCaseStudies, nil
}

// GetOneCaseStudy is the resolver for the getOneCaseStudy field.
func (r *queryResolver) GetOneCaseStudy(ctx context.Context, caseStudyID string) (*generated.CaseStudy, error) {
	// panic(fmt.Errorf("not implemented: GetOneCaseStudy - getOneCaseStudy"))
	var caseStudy models.CaseStudy
	// Fetch case study by ID from the database
	if err := initializers.DB.First(&caseStudy, "id = ?", caseStudyID).Error; err != nil {
		return nil, fmt.Errorf("case study not found: %v", err)
	}
	// Convert model to GraphQL type
	return &generated.CaseStudy{
		CaseStudyID:     fmt.Sprintf("%d", caseStudy.ID), // Ensure correct ID format
		ProjectName:     caseStudy.ProjectName,
		ClientName:      caseStudy.ClientName,
		TechStack:       caseStudy.TechStack,
		ProjectDuration: caseStudy.ProjectDuration,
		KeyOutcomes:     caseStudy.KeyOutcomes,
		IndustryTarget:  caseStudy.IndustryTarget,
		Tags:            caseStudy.Tags,
		Document:        caseStudy.Document,
	}, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
